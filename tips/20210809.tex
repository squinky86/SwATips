Ada is often touted by its supporters as the best programming language ever devised by man. And at least on a conceptual level there are some good arguments in its favor. But as with any complex programming language there are corner cases that should be understood and dealt with carefully to avoid those advantages turning into disadvantages.

Enter the Ada High Integrity Profiles. What are these mysterious profiles? With a name like ``high integrity'' they must be good. And if Ada itself is already the best programming language, then high integrity Ada must be the best of the best, right? Not so fast! As we will see, you may want to avoid these profiles unless you absolutely need them!

Profiles in Ada came out of the 1997 International Real-Time Ada Workshop. The \texttt{Ravenscar} Profile was intended to produce a more lightweight (and provably correct) executable with task scheduling that was more suited to real time applications. It was revised, and eventually included as part of the Ada standard in 2005.\autocite[§ 2.140, \pno~71-74]{20210809:grm} There are several versions of \texttt{Ravenscar} including \texttt{ravenscar-cert}, \texttt{ravenscar-zfp}, and more. Each variant of a profile has different restrictions on what is and is not allowed using that runtime system. The most restrictive are the Zero Footprint Profiles (ZFP). These profiles go to great lengths to make sure that the resulting executable does not link against the Ada runtime library. As such, they offer the least ``bulk'' in the binary image, but also the fewest features. One step above the ZFPs are the ``cert'' variants, which are intended for profiles that have undergone a separate certification. 

Of particular note is the way in which exceptions are handled. Since all of these profiles are attempting to reduce memory footprint, the handling of exceptions is also reduced. The ZFPs in particular have the least exception handling. Exceptions still happen (including user defined), but they must be handled locally. No traditional exception propagation happens in ZFP. There is a ``last chance handler'' that will be called if an exception is not handled locally.\autocite[§ 4.2.6]{20210809:gnathie} In ZFP, this handler must be implemented by the programmer, and the compiler will enforce its existence.

Beyond exceptions, there is an entire gamut of Ada features that are excluded in these profiles.\autocite[§ 4.2.2]{20210809:gnathie} One that was particularly interesting is the restriction on non-library level tagged types. Tagged or managed types are of particular importance to us for code review. Tagged types will automatically have their \texttt{Initialize} procedure called when an object of that type is constructed without an initial value (think constructor but not quite).\autocite{20210809:adap} Without that guaranteed initialization, more complex projects that have to be segmented in order to be analyzed by adacore wind up with tons of false positives about possibly un-initalized variables. We had heard of a company whose Ada programming standard deliberately avoided the use of tagged types. It made little sense to us for them to avoid tagged types until we learned about these profiles and their restrictions.

When Ada is written against embedded systems, it is not uncommon for us to see the use of VxWorks. There are a set of runtime systems and associated profiles for various versions of VxWorks. For this tip, the salient points of profiles in general still apply. It is worth noting that the ``cert'' version of the VxWorks profiles do come with a default last chance handler that by default will print the stack, raise an \texttt{APEX} exception and exit.\autocite[§ A, Replacement of the Default Last Chance Handler]{20210809:gnatugx}

While none of these restrictions are a security concern in and of themselves, it does beg for care to be taken. When combined with the ``continue running at any cost'' mentality that we see quite often one could see a scenario where exceptions effectively go unhandled. Code using \texttt{cert} or \texttt{zfp} profiles, combined with a last chance handler that swallows exceptions, could render an application unstable and vulnerable. Documentation states that all last chance handlers must effectively terminate the application,\autocite[§ 3.1]{20210809:gnathie} but makes no statement that this is enforced. We often see the sin of catching top level exceptions\autocite[\pno~159]{20210809:viega200924} with the mindset of ``continue running at any cost.'' It is just as much of a concern under these conditions as it would be in C++ code.

As a bonus tip, note that even MORE risky code can be obtained with the pragmas \texttt{No\_Exception\_Handlers} and \texttt{No\_Exceptions}. The \texttt{No\_Exception\_Handlers} pragma disallows all exception handlers except for the last chance handler. The \texttt{No\_Exceptions} pragma disables runtime exceptions entirely!\autocite[§ 3.1]{20210809:gnathie}

